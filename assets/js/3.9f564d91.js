(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{166:function(t,e,a){t.exports=a.p+"assets/img/CalendarRange.1cac476d.png"},167:function(t,e,a){t.exports=a.p+"assets/img/explain.7673a6b5.png"},169:function(t,e,a){"use strict";a.r(e);var r=[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"datapicker实现-日期选择组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#datapicker实现-日期选择组件","aria-hidden":"true"}},[this._v("#")]),this._v(" dataPicker实现(日期选择组件)")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"日历组件功能一览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#日历组件功能一览","aria-hidden":"true"}},[this._v("#")]),this._v(" 日历组件功能一览")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"功能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#功能","aria-hidden":"true"}},[this._v("#")]),this._v(" 功能")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("支持单选日期")]),this._v(" "),e("li",[this._v("时间范围选择")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"实现要点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现要点","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现要点")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("计算每个月的天数，以及补上个月的日期以及下个月的日期")]),this._v(" "),e("li",[this._v("Range组件，时间范围，鼠标移入和移出计算出中日历中的range区域实现高亮")]),this._v(" "),e("li",[this._v("Range组件，跨月选择日期时，数据处理")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"datepickerrange组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#datepickerrange组件","aria-hidden":"true"}},[this._v("#")]),this._v(" DatePickerRange组件")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:a(166),alt:"avatar"}}),this._v(" "),e("br")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"组件划分和功能图解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#组件划分和功能图解","aria-hidden":"true"}},[this._v("#")]),this._v(" 组件划分和功能图解")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("p",[e("strong",[this._v("DateCalendarRange组件")])]),this._v(" "),e("p",[this._v("采用两个body组件+一个外层组件组合")])]),this._v(" "),e("li",[e("p",[e("strong",[this._v("DateCalendar组件")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"图解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#图解","aria-hidden":"true"}},[this._v("#")]),this._v(" 图解")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:a(167),alt:"avatar"}}),this._v(" "),e("br")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"获取本月数据与补上月数据和下月数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#获取本月数据与补上月数据和下月数据","aria-hidden":"true"}},[this._v("#")]),this._v(" 获取本月数据与补上月数据和下月数据")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("求上个月需要补的日期数")]),this._v(" "),e("li",[this._v("求本月的天数")]),this._v(" "),e("li",[this._v("求下月要补的天数")])])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//伪代码  计算上个月公式  其实就是这一段逻辑比较绕，每计算一天，i会加一天  ")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n          "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("上个月最后一天  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" 本月第一天的星期数 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" i  \n      "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"c-body组件实现（核心实现）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-body组件实现（核心实现）","aria-hidden":"true"}},[this._v("#")]),this._v(" c-body组件实现（核心实现）")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("body组件是整个日历组件的核心，它负责渲染整个月份，且需要处理日历的"),e("code",[this._v("click")]),this._v("事件，与"),e("code",[this._v("mousermove")]),this._v("事件的业务")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("日期渲染过程")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"接口设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接口设计","aria-hidden":"true"}},[this._v("#")]),this._v(" 接口设计")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("p",[this._v("组件设计为向外暴露minDate和maxDate两个props属性")]),this._v(" "),e("p",[this._v("用来控制选择日期的区间高亮")])]),this._v(" "),e("li",[e("p",[this._v("内部保留一个startTime和endTime")]),this._v(" "),e("p",[this._v("方便在鼠标move时，改变数据，不需要emit到外部。且可以用于watch 自身的startTime和endTime，每次改变时去emit父级组件改变minDate和maxDate就可以了。这样也实现了数据双向流通")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"实现功能思路拆解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现功能思路拆解","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现功能思路拆解")])},function(){var t=this.$createElement,e=this._self._c||t;return e("li",[e("p",[e("strong",[this._v("每一个日期click处理")])]),this._v(" "),e("p",[this._v("点击每一个日期的处理，需要将每次点击的日期，存放在当前组件的状态，我们组件内部用stateTime和endTime来表示，且watch这两个属性的变化，每次有变化时，派发到外部组件去通知修改minDate和maxDate，")]),this._v(" "),e("p",[this._v("如果是单选，就只保留一个minDate,如果是范围选择，就只保留两个，超过则清空")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("c-body的mousemove处理（难点）")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"一些其他的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一些其他的问题","aria-hidden":"true"}},[this._v("#")]),this._v(" 一些其他的问题")])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ul",[a("li",[a("p",[t._v("当前移动的目标Date比StartDate小该如何优雅的处理？")]),t._v(" "),a("p",[t._v("如今的mousemove事件处理，设计思路是，在鼠标move过程中，计算移入的div，拿到日期数据（element-ui-datepickerRange组件内部实现思路也是如此）")]),t._v(" "),a("p",[t._v("如果移动获取到的Date比StartDate小，代表鼠标在往回移动，在move事件中置换两个变量，会出现startTime和endTime每次只差一天的情况，因为目前组件设计只采用start和end两个标志点，在move事件中是如果是反方向移动，是没法置换start和end的，是否需要推翻之前的设计，重新设立第三个标志点来控制区间选择")]),t._v(" "),a("p",[t._v("目前的处理思路")]),t._v(" "),a("p",[t._v("只考虑startDate和endDate只是代表着一个区间，能拿到这个区间，就可以实现高亮了，我们在cell组件内部，每一个日期绑定class的时候，手动判断一次startDate和endDate的大小就可以了，如果start比end大，则互相替换一下需要添加class元素的位置就可以了，不需要直接修改start和end")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"后记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#后记","aria-hidden":"true"}},[this._v("#")]),this._v(" 后记")])}],s=a(0),n=Object(s.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[t._m(0),t._v(" "),a("p",[t._v("之前业务需求，需要写一个性化的日历，用于展示酒店每日价格，由于时间原因，并没有封装为通用的日历组件，如今重新整理了下整体组织结构。重新开发一个新的日历组件。")]),t._v(" "),a("p",[t._v("这篇手记用来梳理、记录日历组件开发历程，其内部实现也参考了iview和element-ui 的DatePicker")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),a("p",[a("a",{attrs:{href:"https://huqc2513.github.io/component/#/calendar",target:"_blank",rel:"noopener noreferrer"}},[t._v("点击体验日历效果"),a("OutboundLink")],1)]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),a("p",[t._v("从以上几个要点，设计整个组件的结构组织")]),t._v(" "),t._m(9),t._v(" "),a("p",[t._v("划分为body组件即可，body组件即可满足单选功能")]),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),a("p",[t._v("日历一般是42个格子，假设日历默认是从周日开始，有些月份1号是周六，一些是周一，要预留中间的前面上个月的日期个数差值，")]),t._v(" "),a("p",[t._v("取得日历数据的步骤")]),t._v(" "),t._m(13),t._v(" "),t._m(14),a("p",[a("a",{attrs:{href:"https://github.com/huqc2513/component/blob/master/src/components/calendar/newCalendar/date.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("代码实现"),a("OutboundLink")],1)]),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),a("p",[t._v("通过将单月的日历数据切分为7*6的二维数组，采用table布局，使用两层v-for渲染，并且将每层的下标挂载到元素上，每个元素上放置着当前日期的数据")]),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),a("ul",[t._m(21),t._v(" "),a("li",[t._m(22),t._v(" "),a("p",[t._v("设计思路是，在鼠标move过程中，计算移入的div，拿到日期数据，并且和startTime和endTime做比较，来判断修改哪一个值实现高亮")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://huqc2513.github.io/component/#/calendar",target:"_blank",rel:"noopener noreferrer"}},[t._v("点击查看鼠标移入日历，高亮区间效果"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("需要实现鼠标移入，从startTime到鼠标移动到的日期，中间间隔的的日期全部高亮")]),t._v(" "),a("p",[t._v("我们采用修改日期数据列表的方式来达到，这一步其实很简单，移动过程中，拿到目标元素中绑定的row和column下标，取得元素中的Date,将Date和startTime比较，如果比 StartTime大，就设置为endTime就行。")])])]),t._v(" "),t._m(23),t._v(" "),a("p",[t._v("整个组件中的重点实现已经记录完了，类似head组件和cell组件只剩下一些props声明和简单的判断year,month条件等，目前也留下了一些问题，有待重构部分代码")]),t._v(" "),t._m(24),t._v(" "),t._m(25),t._v(" "),a("p",[t._v("这篇手记基本就是用来记录其实现过程的一些思路，没有任何代码展示，对于复杂组件，业务逻辑，往往只需要将业务梳理清楚了，代码就好写很多了，\n也可以从市面上的开源VueUI框架参考其实现原理。参考别人好的实现，汲取精华，也是积累与成长")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://github.com/huqc2513/component/tree/master/src/components/calendar/newCalendar",target:"_blank",rel:"noopener noreferrer"}},[t._v("点击查看日历组件码地址"),a("OutboundLink")],1)])])},r,!1,null,null,null);e.default=n.exports}}]);