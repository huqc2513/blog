(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{171:function(t,e,n){"use strict";n.r(e);var r=n(0),a=Object(r.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),n("p",[t._v("使用hashHistory模式,url后面会带有#号不太美观,而使用history模式，就是正常的url，但是如果匹配不到这个路由就会出现404请求。这种情况需要在服务器配置,如果URL匹配不到任何静态资源，就跳转到默认的index.html。")]),t._v(" "),n("p",[t._v("这里将会实现这两种路由模式")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),n("br"),t._v(" "),t._m(7),t._v(" "),n("p",[t._v("window.history 对象表示窗口的浏览历史,它只有back()、forward() 和 go() 方法可以让用户调用,\n而h5规范中又新增了几个关于操作history记录的APi,分别是replaceState,pushState,popstate")]),t._v(" "),n("p",[t._v("在点击浏览器前进和后退的时候，都会触发popstate事件，而采用pushState和replaceState不会触发此事件")]),t._v(" "),t._m(8),n("br"),t._v(" "),t._m(9),t._v(" "),n("p",[t._v("有了以上的知识点，就可以动手写组件了，在动手写组件之前，先来看看官方路由的具体用法，才能知道如何去设计这些组件")]),t._v(" "),n("p",[t._v("react-router-dom中引出了很多的组件，模块中向外部导出接口，常见的做法是文件夹中有一个index.js向外暴露出这个模块的所有接口，")]),t._v(" "),n("p",[t._v("所以可以设计为react-router-dom文件夹会下放置一堆组件，通过一个index.js，向外部导出接口对接")]),t._v(" "),t._m(10),t._m(11),t._v(" "),n("p",[t._v("想要写一个通用组件，首先先设想好该组件的使用方式，官方的路由使用方式如下")]),t._v(" "),t._m(12),n("p",[t._v("可以看到 Router组件div里面的最外层的组件，而里面的route、Switch组件等，它里面的每个子组件都可以从props中拿到Router组件中的所有数据")]),t._v(" "),n("p",[t._v("router可以看作是顶级组件用于提供数据,父子组件通信一般做法是采用porps向下级传递的方法，但如父子组件中间跨了多个子组件，采用props传值就很麻烦，所以采用组件的context来传递共享数据，")]),t._v(" "),n("p",[t._v("而每个包裹在Router下的组件都能从props中获取到一些共用数据,这里展示了router组件中的部分state状态")]),t._v(" "),t._m(13),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),n("p",[t._v("在hashRouter顶级组件中使用Provider组件,里面每个子组件中外层采用Consumer包裹，这样每个组件都能拿到provider的数据")]),t._v(" "),t._m(17),t._v(" "),n("p",[t._v("hashRouter用于提供hisotry的数据以及方法给到子组件，以及监听hashchange事件，提供push,go等方法等")]),t._v(" "),t._m(18),n("p",[t._v("hashRouter组件state中的的push方法，直接将 window.location.hash值改变，会触发haschange事件，而在componentDidMount钩子函数中，监听hashchange事件中，在变化后将hash值存入state中")]),t._v(" "),t._m(19),t._v(" "),t._m(20),t._v(" "),t._m(21),n("p",[t._v("正常情况下,url可能会有这几种情况，如/foo/bar,  或者/foo:123，")]),t._v(" "),n("p",[t._v("这种url如果不处理，默认是匹配不到的，而exact参数就是控制是否精确匹配")]),t._v(" "),n("p",[t._v("这里引入了 "),n("a",{attrs:{href:"https://www.npmjs.com/package/path-to-regexp",target:"_blank",rel:"noopener noreferrer"}},[t._v("pathToRegexp"),n("OutboundLink")],1),t._v("库来生成正则表达式，来处理 url 中地址查询参数")]),t._v(" "),t._m(22),t._m(23),t._v(" "),t._m(24),t._v(" "),t._m(25),n("p",[t._v("Switch组件将传入的children，遍历拿到每一个组件传入的path，并生成正则，如果正则能够匹配的上，则直接渲染child,否则return null,确保switch中包裹的子组件，只能渲染其中一个，switch组件是用于配合redirect组件来使用的")]),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),t._m(28),n("p",[t._v("redirect组件实现非常简单，如果该组件渲染，直接将window.location.hash = to")]),t._v(" "),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._m(32),t._v(" "),t._m(33),t._v(" "),t._m(34),n("br"),t._v(" "),t._m(35),t._v(" "),n("p",[t._v("简易版的router组件到这里就实现的差不多了，但是还是有很多功能没实现，比如query参数处理，link组件等")]),t._v(" "),n("p",[t._v("代码地址 : "),n("a",{attrs:{href:"https://github.com/huqc2513/react-note.git",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/huqc2513/react-note.git"),n("OutboundLink")],1)])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"手写一个react路由"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手写一个react路由","aria-hidden":"true"}},[this._v("#")]),this._v(" 手写一个react路由")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"路由模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由模式","aria-hidden":"true"}},[this._v("#")]),this._v(" 路由模式")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("用过react-router的会比较熟悉react路由模式，一般有两种，分别是"),e("code",[this._v("hashHistory")]),this._v("和"),e("code",[this._v("history")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现原理","aria-hidden":"true"}},[this._v("#")]),this._v(" 实现原理")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("hashHistory路由")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("hash值变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 hashchange 事件，浏览器的进后退也能对其进行控制,\n如"),e("code",[this._v("http://localhost:3000/detail#/home")]),this._v("这段url的#号后面的就为hash值,window.location.hash 取到的就是#home")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v(" window.addEventListener ('hashchange',  (e)=> {\n        this.setState({\n            location:{\n               hash:window.location.hash\n               pathname:window.location.hash\n            },\n      })\n });\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("history路由")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("代码示例\n/*\n  state   要跳转到的URL对应的状态信息，可以存一些需要想保存的值，也可以直接传{}\n  title   该条记录的title,现在大多数浏览器不支持或者忽略这个参数\n  url     这个参数提供了新历史纪录的地址,可以是相对路径，不可跨域\n*/\n\nwindow.history.pushState(state, title, url) \n//replaceState和pushState的不同之处在与，replace是替换栈顶上的那个元素，不会影响栈的长度\nwindow.history.replaceState(state, title, url) \n\n//例子\n window.addEventListener('popstate',(e)=>{\n      this.setState({\n        ...this.state,\n        location:{\n          ...location,\n          pathname:e.state.path,\n        },\n      })\n })\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"设计路由组件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计路由组件","aria-hidden":"true"}},[this._v("#")]),this._v(" 设计路由组件")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("├─ react-router-dom/\n│  ├─ index.js\n│  ├─ HashRouter.js\n│  └─ Route.js\n   ├─ Link.js\n   └─ ...\n\n//使用\n\nimport {  HashRouter as Router, Route,Link, Redirect,Switch,} from './react-router-dom';\n\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"路由中的组件使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由中的组件使用","aria-hidden":"true"}},[this._v("#")]),this._v(" 路由中的组件使用")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('//router.js  配置路由\nexport default const BasicRouter = () => {\n    return (\n        <div>\n          <Router>\n            <div>\n            <div>\n              <Link to="/home">首页</Link>\n              <Link to="/detail">详情</Link>\n            </div>\n              <Switch>\n                <Route  path="/home" component={Home} />\n                <Route  path="/detail" component={Detail} />\n                <Redirect to="/home" />\n              </Switch>\n            </div>\n          </Router>\n        </div>\n    )\n}\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("//使用路由后，在所有子组件中打印this.props    这些数据为Router中的state\n{\n    history:{\n      replace:e=>{},  \n      push:e=>{},  \n    },\n    match:{\n        params:'',\n        isExact:false\n    },\n    location:{\n        pathname:'',\n        hash:'',\n    }\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"context实现（provider组件）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#context实现（provider组件）","aria-hidden":"true"}},[this._v("#")]),this._v(" context实现（Provider组件）")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("熟悉redux的人应该都知道，store中的共享状态需要通过一个顶层组件作为父组件，一般将顶级组件叫做Provider组件，由它内部创建context来作为数据的提供者\n"),e("br"),this._v("例如redux中的connect方法，它就是一个HOC组件，connext方法的参数在函数中通过解构拿到store中的数据，再通过props的方式给到connext传入的组件中，而在react 16.3版本中新增createContext方法，它返回了Provider, Consumer组件等，")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("//context.js\n\nimport React from 'react';\nlet { Provider,Consumer } = React.createContext()\nexport  { Provider, Consumer}\n\n//顶级组件\n\nimport { Provider } from './context'\n<Provider value={this.state}>\n    {this.props.children}  \n</Provider>\n\n//所有的子级组件 Consumer里面的childer是一个函数，由函数来返回渲染的块，state就是provider传入的value\n\nimport { Consumer} from './context'\nrender(){\n      <Consumer>\n            {state => {\n              //这里的state就是provider传入的value\n              if(state.pathname===path){\n               return  this.props.component\n              }\n              return null\n            }}\n       </Consumer>\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"hashrouter-js-实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashrouter-js-实现","aria-hidden":"true"}},[this._v("#")]),this._v(" hashRouter.js 实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("//react-router-dom文件夹下hashRouter.js\n\nimport React, {Component} from 'react';\nimport {Provider} from './context';\n\nexport default class HashRouter extends Component {\n  constructor () {\n    super (...arguments);\n    this.state = {\n      location: {\n        pathname: window.location.hash.slice(1), //去除#号\n        hash: window.location.hash,\n      },\n      history:{\n        push(to){\n            window.location.hash = to\n        }\n      }\n    };\n  }\n\n  componentDidMount () {\n    let location  = this.state\n    window.addEventListener ('hashchange',  (e)=> {\n      this.setState ({\n        location: {\n          ...location,\n          hash:window.location.hash,\n          pathname: window.location.hash.slice (1) || '',  //去除#号\n        },\n      });\n    });\n  }\n  render () {\n    return (\n      <Provider value={this.state}>\n        {this.props.children}\n      </Provider>\n    );\n  }\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"route-js实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#route-js实现","aria-hidden":"true"}},[this._v("#")]),this._v(" Route.js实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("该组件用来接受component和path，以及渲染传入的组件")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("import React, {Component} from 'react';\nimport { Consumer} from './context'\nconst pathToRegexp = require('path-to-regexp');\n\nexport default class Route extends Component {\n  constructor () {\n    super (...arguments)\n  }\n  render () {\n    let { path, component: Component, exact=false } = this.props;\n    return (\n      <Consumer>\n        {state => { \n        //pathToRegexp 方法，第一个参数，\n          let reg= pathToRegexp(path,[],{end:exact })\n          let pathname = state.location.pathname\n          if (reg.test(pathname)) {\n            return <Component {...state} />;\n          }\n          return null;\n        }}\n      </Consumer>\n    );\n  }\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("//示例代码\n\n\n//如果需要精确匹配,将pathToRegexp的第三个参数end传为true,pathToRegexp第二个参数是匹配到的值\nlet ret = []\nvar re = pathToRegexp('/detail',ret,{\n    end:true \n})\nre.test('/foo/1')  // true\n\n//生成的正则\n/^\\/detail(?:\\/)?$/i                \n/^\\/detail(?:\\/(?=$))?(?=\\/|$)/i     \n\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"switch-js实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#switch-js实现","aria-hidden":"true"}},[this._v("#")]),this._v(" Switch.js实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("用于匹配只渲染一个route组件")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("import React, {Component} from 'react';\nimport { Consumer} from './context'\nconst pathToRegexp = require('path-to-regexp');\n\nexport default class Switch extends Component {\n  constructor () {\n    super (...arguments);\n  }\n\n  render () {\n    return (\n      <Consumer>\n        {state => {\n          let pathname =state.location.pathname;\n          let children = this.props.children\n          for(let i=0;i<children.length;i++){\n            let child = children[i]\n            let path = child.props.path || ''\n            let reg =  pathToRegexp(path,[],{end:false})\n            if(reg.test(pathname)){\n              return child\n            }\n          }\n          return null\n        }}\n      </Consumer>\n    );\n  }\n}\n\n\n //使用Switchs\n \n <Switch>\n        <Route  path=\"/home\" component={Home} />\n        <Route  path=\"/detail\" component={Detail} />\n        <Redirect to=\"/home\"/>\n</Switch>\n\n\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"redirect-js实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redirect-js实现","aria-hidden":"true"}},[this._v("#")]),this._v(" redirect.js实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("用于重定向")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("import React, {Component} from 'react';\nimport { Consumer} from './context'\n\nexport default class Redirect extends Component {\n  constructor () {\n    super (...arguments);\n  }\n\n  render () {\n    return (\n      <Consumer>\n        {state => {\n          let { history }= state;\n          history.push(this.props.to)\n          return null\n        }}\n      </Consumer>\n    );\n  }\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"browserrouter-js的实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#browserrouter-js的实现","aria-hidden":"true"}},[this._v("#")]),this._v(" browserRouter.js的实现")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("browserRouter与hashRouter的实现不同点是，在state的push方法中调用window.history.pushState，压入后，浏览器的url会直接变化页面不会刷新，另外popstate监听事件，也需要同步一次state里面的pathname")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("import React, {Component} from 'react';\nimport {Provider} from './context';\n\nclass browserRouter extends Component {\n  constructor () {\n    super (...arguments);\n    this.state = {\n      location: {\n        pathname: window.location.pathname ,\n        hash: window.location.hash,\n      },\n      history:{\n        push :(to)=>{\n          this.pushState(null,null,to)  \n        }\n      },\n      queue:[]      \n    };\n    this.pushState = this.pushState.bind(this)\n  }\n\n\n  pushState = (state=\"\",title=\"\",path=\"\")=>{\n       let queue  = this.state.queue\n       let {location}  = this.state \n       let historyInfo ={state,title,path}\n       queue.push( historyInfo)\n       this.setState({\n        ...this.state,\n        location:{\n          ...location,\n          pathname:path,\n        },\n        queue,\n      })\n      window.history.pushState(historyInfo,title,path)\n  }\n\n  componentDidMount () {\n    let {location}  = this.state \n    window.addEventListener('popstate',(e)=>{\n      this.setState({\n        ...this.state,\n        location:{\n          ...location,\n          pathname:e.state.path,\n        },\n        queue:this.state.queue,\n      })\n    })\n  }\n\n  render () {\n    return (\n      <Provider value={this.state}>\n        {this.props.children}\n      </Provider>\n    );\n  }\n}\n\nexport default browserRouter;\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"示例代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#示例代码","aria-hidden":"true"}},[this._v("#")]),this._v(" 示例代码")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("1.新建一个router.js，用于管理route组件"),e("br"),this._v("\n2.在index.js中导入使用")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("\nimport React from 'react';\nimport {\n   HashRouter as Router,\n  //  BrowserRouter as Router,\n  Route,\n  Link,\n  Redirect,\n  Switch,\n} from './react-router-dom';\n\nimport Home from './pages/home';\nimport Detail from './pages/detail';  \n\nconst BasicRoute = () => {\n  return (\n    <div>\n      <Router>\n        <div>\n        <div>\n          <Link to=\"/home\">首页</Link>\n          <Link to=\"/detail\">详情</Link>\n        </div>\n          <Switch>\n            <Route  path=\"/home\" component={Home} />\n            <Route  path=\"/detail\" component={Detail} />\n            <Redirect to=\"/home\" />\n          </Switch>\n        </div>\n\n      </Router>\n    </div>\n  );\n};\nexport default BasicRoute;\n\n\n// index.js中 使用\n\nimport Router from './router'\nReactDOM.render(<Router/>, document.getElementById('root'));\n\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"结尾"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结尾","aria-hidden":"true"}},[this._v("#")]),this._v(" 结尾")])}],!1,null,null,null);e.default=a.exports}}]);