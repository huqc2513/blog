<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>路由模式 | blog</title>
    <meta name="description" content="个人博客">
    
    
    <link rel="preload" href="/blog/assets/css/0.styles.e78083b5.css" as="style"><link rel="preload" href="/blog/assets/js/app.9854679f.js" as="script"><link rel="preload" href="/blog/assets/js/6.6879b34d.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.28d46195.js"><link rel="prefetch" href="/blog/assets/js/11.f91590e2.js"><link rel="prefetch" href="/blog/assets/js/12.343221fc.js"><link rel="prefetch" href="/blog/assets/js/13.fcc7d565.js"><link rel="prefetch" href="/blog/assets/js/14.dee9b30c.js"><link rel="prefetch" href="/blog/assets/js/15.78791309.js"><link rel="prefetch" href="/blog/assets/js/16.ccc31f4c.js"><link rel="prefetch" href="/blog/assets/js/17.4802b3d9.js"><link rel="prefetch" href="/blog/assets/js/18.cc8384fe.js"><link rel="prefetch" href="/blog/assets/js/19.ef906264.js"><link rel="prefetch" href="/blog/assets/js/2.9b3a1008.js"><link rel="prefetch" href="/blog/assets/js/20.4eaeffd3.js"><link rel="prefetch" href="/blog/assets/js/21.83ddc548.js"><link rel="prefetch" href="/blog/assets/js/22.d83ce626.js"><link rel="prefetch" href="/blog/assets/js/23.27788534.js"><link rel="prefetch" href="/blog/assets/js/24.af86ecb4.js"><link rel="prefetch" href="/blog/assets/js/25.98f09d1d.js"><link rel="prefetch" href="/blog/assets/js/3.cd327195.js"><link rel="prefetch" href="/blog/assets/js/4.a08fc300.js"><link rel="prefetch" href="/blog/assets/js/5.135cabbe.js"><link rel="prefetch" href="/blog/assets/js/7.6de8c02d.js"><link rel="prefetch" href="/blog/assets/js/8.92cce762.js"><link rel="prefetch" href="/blog/assets/js/9.b4108cdc.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.e78083b5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">blog</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/vue/emitter/vue组件之间的多种通信方式.html" class="nav-link">vue</a></div><div class="nav-item"><a href="/blog/react/手写一个react路由.html" class="nav-link">react</a></div> <a href="https://github.com/huqc2513" target="_blank" rel="noopener noreferrer" class="repo-link">
    github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/vue/emitter/vue组件之间的多种通信方式.html" class="nav-link">vue</a></div><div class="nav-item"><a href="/blog/react/手写一个react路由.html" class="nav-link">react</a></div> <a href="https://github.com/huqc2513" target="_blank" rel="noopener noreferrer" class="repo-link">
    github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first collapsable"><p class="sidebar-heading open"><span>react</span> <span class="arrow down"></span></p> <ul class="sidebar-group-items"><li><a href="/blog/react/手写一个react路由.html" class="sidebar-link">手写一个react路由</a></li></ul></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>node</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></div></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>javascript</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="路由模式"><a href="#路由模式" aria-hidden="true" class="header-anchor">#</a> 路由模式</h2> <p>用过react-router的会比较熟悉react路由模式，一般有两种，分别是<code>hashHistory</code>和<code>history</code></p> <p>使用hashHistory模式,url后面会带有#号不太美观,而使用history模式，就是正常的url，但是如果匹配不到这个路由就会出现404请求。这种情况需要在服务器配置,如果URL匹配不到任何静态资源，就跳转到默认的index.html。</p> <p>这里将会实现这两种路由模式</p> <h2 id="实现原理"><a href="#实现原理" aria-hidden="true" class="header-anchor">#</a> 实现原理</h2> <ul><li>hashHistory路由</li></ul> <p>hash值变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 hashchange 事件，浏览器的进后退也能对其进行控制,
如<code>http://localhost:3000/detail#/home</code>这段url的#号后面的就为hash值,window.location.hash 取到的就是#home</p> <div class="language- extra-class"><pre class="language-text"><code> window.addEventListener ('hashchange',  (e)=&gt; {
        this.setState({
            location:{
               hash:window.location.hash
               pathname:window.location.hash
            },
      })
 });
</code></pre></div><br> <ul><li>history路由</li></ul> <p>window.history 对象表示窗口的浏览历史,它只有back()、forward() 和 go() 方法可以让用户调用,
而h5规范中又新增了几个关于操作history记录的APi,分别是replaceState,pushState,popstate</p> <p>在点击浏览器前进和后退的时候，都会触发popstate事件，而采用pushState和replaceState不会触发此事件</p> <div class="language- extra-class"><pre class="language-text"><code>代码示例
/*
  state   要跳转到的URL对应的状态信息，可以存一些需要想保存的值，也可以直接传{}
  title   该条记录的title,现在大多数浏览器不支持或者忽略这个参数
  url     这个参数提供了新历史纪录的地址,可以是相对路径，不可跨域
*/

window.history.pushState(state, title, url) 
//replaceState和pushState的不同之处在与，replace是替换栈顶上的那个元素，不会影响栈的长度
window.history.replaceState(state, title, url) 

//例子
 window.addEventListener('popstate',(e)=&gt;{
      this.setState({
        ...this.state,
        location:{
          ...location,
          pathname:e.state.path,
        },
      })
 })
</code></pre></div><br> <h2 id="设计路由组件"><a href="#设计路由组件" aria-hidden="true" class="header-anchor">#</a> 设计路由组件</h2> <p>有了以上的知识点，就可以动手写组件了，在动手写组件之前，先来看看官方路由的具体用法，才能知道如何去设计这些组件</p> <p>react-router-dom中引出了很多的组件，模块中向外部导出接口，常见的做法是文件夹中有一个index.js向外暴露出这个模块的所有接口，</p> <p>所以可以设计为react-router-dom文件夹会下放置一堆组件，通过一个index.js，向外部导出接口对接</p> <div class="language- extra-class"><pre class="language-text"><code>├─ react-router-dom/
│  ├─ index.js
│  ├─ HashRouter.js
│  └─ Route.js
   ├─ Link.js
   └─ ...

//使用

import {  HashRouter as Router, Route,Link, Redirect,Switch,} from './react-router-dom';

</code></pre></div><h3 id="路由中的组件使用"><a href="#路由中的组件使用" aria-hidden="true" class="header-anchor">#</a> 路由中的组件使用</h3> <p>想要写一个通用组件，首先先设想好该组件的使用方式，官方的路由使用方式如下</p> <div class="language- extra-class"><pre class="language-text"><code>//router.js  配置路由
export default const BasicRouter = () =&gt; {
    return (
        &lt;div&gt;
          &lt;Router&gt;
            &lt;div&gt;
            &lt;div&gt;
              &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;
              &lt;Link to=&quot;/detail&quot;&gt;详情&lt;/Link&gt;
            &lt;/div&gt;
              &lt;Switch&gt;
                &lt;Route  path=&quot;/home&quot; component={Home} /&gt;
                &lt;Route  path=&quot;/detail&quot; component={Detail} /&gt;
                &lt;Redirect to=&quot;/home&quot; /&gt;
              &lt;/Switch&gt;
            &lt;/div&gt;
          &lt;/Router&gt;
        &lt;/div&gt;
    )
}
</code></pre></div><p>可以看到 Router组件div里面的最外层的组件，而里面的route、Switch组件等，它里面的每个子组件都可以从props中拿到Router组件中的所有数据</p> <p>router可以看作是顶级组件用于提供数据,父子组件通信一般做法是采用porps向下级传递的方法，但如父子组件中间跨了多个子组件，采用props传值就很麻烦，所以采用组件的context来传递共享数据，</p> <p>而每个包裹在Router下的组件都能从props中获取到一些共用数据,这里展示了router组件中的部分state状态</p> <div class="language- extra-class"><pre class="language-text"><code>//使用路由后，在所有子组件中打印this.props    这些数据为Router中的state
{
    history:{
      replace:e=&gt;{},  
      push:e=&gt;{},  
    },
    match:{
        params:'',
        isExact:false
    },
    location:{
        pathname:'',
        hash:'',
    }
}
</code></pre></div><h2 id="context实现（provider组件）"><a href="#context实现（provider组件）" aria-hidden="true" class="header-anchor">#</a> context实现（Provider组件）</h2> <p>熟悉redux的人应该都知道，store中的共享状态需要通过一个顶层组件作为父组件，一般将顶级组件叫做Provider组件，由它内部创建context来作为数据的提供者
<br>例如redux中的connect方法，它就是一个HOC组件，connext方法的参数在函数中通过解构拿到store中的数据，再通过props的方式给到connext传入的组件中，而在react 16.3版本中新增createContext方法，它返回了Provider, Consumer组件等，</p> <div class="language- extra-class"><pre class="language-text"><code>//context.js

import React from 'react';
let { Provider,Consumer } = React.createContext()
export  { Provider, Consumer}

//顶级组件

import { Provider } from './context'
&lt;Provider value={this.state}&gt;
    {this.props.children}  
&lt;/Provider&gt;

//所有的子级组件 Consumer里面的childer是一个函数，由函数来返回渲染的块，state就是provider传入的value

import { Consumer} from './context'
render(){
      &lt;Consumer&gt;
            {state =&gt; {
              //这里的state就是provider传入的value
              if(state.pathname===path){
               return  this.props.component
              }
              return null
            }}
       &lt;/Consumer&gt;
}
</code></pre></div><p>在hashRouter顶级组件中使用Provider组件,里面每个子组件中外层采用Consumer包裹，这样每个组件都能拿到provider的数据</p> <h2 id="hashrouter-js-实现"><a href="#hashrouter-js-实现" aria-hidden="true" class="header-anchor">#</a> hashRouter.js 实现</h2> <p>hashRouter用于提供hisotry的数据以及方法给到子组件，以及监听hashchange事件，提供push,go等方法等</p> <div class="language- extra-class"><pre class="language-text"><code>//react-router-dom文件夹下hashRouter.js

import React, {Component} from 'react';
import {Provider} from './context';

export default class HashRouter extends Component {
  constructor () {
    super (...arguments);
    this.state = {
      location: {
        pathname: window.location.hash.slice(1), //去除#号
        hash: window.location.hash,
      },
      history:{
        push(to){
            window.location.hash = to
        }
      }
    };
  }

  componentDidMount () {
    let location  = this.state
    window.addEventListener ('hashchange',  (e)=&gt; {
      this.setState ({
        location: {
          ...location,
          hash:window.location.hash,
          pathname: window.location.hash.slice (1) || '',  //去除#号
        },
      });
    });
  }
  render () {
    return (
      &lt;Provider value={this.state}&gt;
        {this.props.children}
      &lt;/Provider&gt;
    );
  }
}
</code></pre></div><p>hashRouter组件state中的的push方法，直接将 window.location.hash值改变，会触发haschange事件，而在componentDidMount钩子函数中，监听hashchange事件中，在变化后将hash值存入state中</p> <h2 id="route-js实现"><a href="#route-js实现" aria-hidden="true" class="header-anchor">#</a> Route.js实现</h2> <blockquote><p>该组件用来接受component和path，以及渲染传入的组件</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>import React, {Component} from 'react';
import { Consumer} from './context'
const pathToRegexp = require('path-to-regexp');

export default class Route extends Component {
  constructor () {
    super (...arguments)
  }
  render () {
    let { path, component: Component, exact=false } = this.props;
    return (
      &lt;Consumer&gt;
        {state =&gt; { 
        //pathToRegexp 方法，第一个参数，
          let reg= pathToRegexp(path,[],{end:exact })
          let pathname = state.location.pathname
          if (reg.test(pathname)) {
            return &lt;Component {...state} /&gt;;
          }
          return null;
        }}
      &lt;/Consumer&gt;
    );
  }
}
</code></pre></div><p>正常情况下,url可能会有这几种情况，如/foo/bar,  或者/foo:123，</p> <p>这种url如果不处理，默认是匹配不到的，而exact参数就是控制是否精确匹配</p> <p>这里引入了 <a href="https://www.npmjs.com/package/path-to-regexp" target="_blank" rel="noopener noreferrer">pathToRegexp<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>库来生成正则表达式，来处理 url 中地址查询参数</p> <div class="language- extra-class"><pre class="language-text"><code>//示例代码


//如果需要精确匹配,将pathToRegexp的第三个参数end传为true,pathToRegexp第二个参数是匹配到的值
let ret = []
var re = pathToRegexp('/detail',ret,{
    end:true 
})
re.test('/foo/1')  // true

//生成的正则
/^\/detail(?:\/)?$/i                
/^\/detail(?:\/(?=$))?(?=\/|$)/i     

</code></pre></div><h2 id="switch-js实现"><a href="#switch-js实现" aria-hidden="true" class="header-anchor">#</a> Switch.js实现</h2> <blockquote><p>用于匹配只渲染一个route组件</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>import React, {Component} from 'react';
import { Consumer} from './context'
const pathToRegexp = require('path-to-regexp');

export default class Switch extends Component {
  constructor () {
    super (...arguments);
  }

  render () {
    return (
      &lt;Consumer&gt;
        {state =&gt; {
          let pathname =state.location.pathname;
          let children = this.props.children
          for(let i=0;i&lt;children.length;i++){
            let child = children[i]
            let path = child.props.path || ''
            let reg =  pathToRegexp(path,[],{end:false})
            if(reg.test(pathname)){
              return child
            }
          }
          return null
        }}
      &lt;/Consumer&gt;
    );
  }
}


 //使用Switchs
 
 &lt;Switch&gt;
        &lt;Route  path=&quot;/home&quot; component={Home} /&gt;
        &lt;Route  path=&quot;/detail&quot; component={Detail} /&gt;
        &lt;Redirect to=&quot;/home&quot;/&gt;
&lt;/Switch&gt;


</code></pre></div><p>Switch组件将传入的children，遍历拿到每一个组件传入的path，并生成正则，如果正则能够匹配的上，则直接渲染child,否则return null,确保switch中包裹的子组件，只能渲染其中一个，switch组件是用于配合redirect组件来使用的</p> <h2 id="redirect-js实现"><a href="#redirect-js实现" aria-hidden="true" class="header-anchor">#</a> redirect.js实现</h2> <blockquote><p>用于重定向</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>import React, {Component} from 'react';
import { Consumer} from './context'

export default class Redirect extends Component {
  constructor () {
    super (...arguments);
  }

  render () {
    return (
      &lt;Consumer&gt;
        {state =&gt; {
          let { history }= state;
          history.push(this.props.to)
          return null
        }}
      &lt;/Consumer&gt;
    );
  }
}
</code></pre></div><p>redirect组件实现非常简单，如果该组件渲染，直接将window.location.hash = to</p> <h2 id="browserrouter-js的实现"><a href="#browserrouter-js的实现" aria-hidden="true" class="header-anchor">#</a> browserRouter.js的实现</h2> <blockquote><p>browserRouter与hashRouter的实现不同点是，在state的push方法中调用window.history.pushState，压入后，浏览器的url会直接变化页面不会刷新，另外popstate监听事件，也需要同步一次state里面的pathname</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>import React, {Component} from 'react';
import {Provider} from './context';

class browserRouter extends Component {
  constructor () {
    super (...arguments);
    this.state = {
      location: {
        pathname: window.location.pathname ,
        hash: window.location.hash,
      },
      history:{
        push :(to)=&gt;{
          this.pushState(null,null,to)  
        }
      },
      queue:[]      
    };
    this.pushState = this.pushState.bind(this)
  }


  pushState = (state=&quot;&quot;,title=&quot;&quot;,path=&quot;&quot;)=&gt;{
       let queue  = this.state.queue
       let {location}  = this.state 
       let historyInfo ={state,title,path}
       queue.push( historyInfo)
       this.setState({
        ...this.state,
        location:{
          ...location,
          pathname:path,
        },
        queue,
      })
      window.history.pushState(historyInfo,title,path)
  }

  componentDidMount () {
    let {location}  = this.state 
    window.addEventListener('popstate',(e)=&gt;{
      this.setState({
        ...this.state,
        location:{
          ...location,
          pathname:e.state.path,
        },
        queue:this.state.queue,
      })
    })
  }

  render () {
    return (
      &lt;Provider value={this.state}&gt;
        {this.props.children}
      &lt;/Provider&gt;
    );
  }
}

export default browserRouter;
</code></pre></div><h2 id="示例代码"><a href="#示例代码" aria-hidden="true" class="header-anchor">#</a> 示例代码</h2> <p>1.新建一个router.js，用于管理route组件<br>
2.在index.js中导入使用</p> <div class="language- extra-class"><pre class="language-text"><code>
import React from 'react';
import {
   HashRouter as Router,
  //  BrowserRouter as Router,
  Route,
  Link,
  Redirect,
  Switch,
} from './react-router-dom';

import Home from './pages/home';
import Detail from './pages/detail';  

const BasicRoute = () =&gt; {
  return (
    &lt;div&gt;
      &lt;Router&gt;
        &lt;div&gt;
        &lt;div&gt;
          &lt;Link to=&quot;/home&quot;&gt;首页&lt;/Link&gt;
          &lt;Link to=&quot;/detail&quot;&gt;详情&lt;/Link&gt;
        &lt;/div&gt;
          &lt;Switch&gt;
            &lt;Route  path=&quot;/home&quot; component={Home} /&gt;
            &lt;Route  path=&quot;/detail&quot; component={Detail} /&gt;
            &lt;Redirect to=&quot;/home&quot; /&gt;
          &lt;/Switch&gt;
        &lt;/div&gt;

      &lt;/Router&gt;
    &lt;/div&gt;
  );
};
export default BasicRoute;


// index.js中 使用

import Router from './router'
ReactDOM.render(&lt;Router/&gt;, document.getElementById('root'));

</code></pre></div><br> <h3 id="结尾"><a href="#结尾" aria-hidden="true" class="header-anchor">#</a> 结尾</h3> <p>简易版的router组件到这里就实现的差不多了，但是还是有很多功能没实现，比如query参数处理，link组件等</p> <p>代码地址 : <a href="https://github.com/huqc2513/react-note.git" target="_blank" rel="noopener noreferrer">https://github.com/huqc2513/react-note.git<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/blog/assets/js/app.9854679f.js" defer></script><script src="/blog/assets/js/6.6879b34d.js" defer></script>
  </body>
</html>
